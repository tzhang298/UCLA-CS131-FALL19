1. First I used brute force to recursively look at the list a and see if the element is in b, if not exit and return false. However, I found a good function in List Module: List.for_all which is exactly what I need for this part. 2. equal sets means they are subset of each other. 3. iterate through a and see if it is in b, if no, then add it to b. if yes, then go to the next element. When there is no element left, return b. 4. List.filter is a very good function. It can select all the elements which satisfy the specific predicate. In this case, I want the element which is in a and also in b. 5. Same as Q4, but I want the element which is in a but not in b. 6. compute fixed point is to recursively compute f(x) on x and until f(x) and x satisfy the equality predicate and return x . In this case, x could be f(x), f(f(x))… 7. Multiple functions are needed. 
	determine_nt: we iterate through the rules’ list and find if the element is Non terminal by looking at the first letter. 
	filter: we have a non-terminal and a rules’ list as input, then we check every pair in the list and see if the non-terminal matches, if match then go to the determine_nt and see if there is non-terminal element in the pair. Add them to a list. 
	filter_list: it calls reachable on every element and add all non_terminal elements to the list. 
	convert_to_list: create a new list with elements that the newly non-terminal reachable list and original one have in common. 
	reachable_rules: it uses the create_list function which takes compute_fixed_point which generates the list of reachables. equal_sets means when the non-terminal matches with another, the loop with stop. the x is the starting symbol. 
	